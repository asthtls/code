# 2020 03 31

# 시스템 프로그래밍

#시스템콜과 API

시스템 프로그래밍 기반 요소
-시스템 콜
-C 라이브러리
-C 컴파일러

사용자 영역에서 커널 영역에 요청을 하게 해주는 것이 시스템콜 
커널 영역이 C언어로 개발되어 있기 때문에 시스템콜 또한 C언어 -> C언어 사용자 프로그램이라면 바로 사용 가능
유사한 몇몇 함수를 묶어 라이브러리를 만듬 = API = # include <??>

시스템콜 : 운영체제 리소스나 서비스 요청을 위해, 사용자 영역에서 커널 영역으로 들어가는 함수
-주요 시스템콜: read(), write(),open() 등

*리눅스/유닉스는 c언어로 개발, 시스템콜 또한 c언어

시스템콜은 어떻게 구현되는가
-eax 레지스터에 시스템 콜 번호를 넣고
-ebx 레스터에는 시스템 콜에 해당하는 인자값을 넣고
-소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨준다
예)
mov eax(레지스터), 1(시스템콜 번호)
mov ebx, 0(함수 인자)
int 0.80 // 소프트웨어 인터럽트 명령

-1. cpu는 사용자 모드를 커널 모드로 바꿔줌
-2. idt(interrupt descripteor table)에서 0x80에 해당하는 주소 함수)를 찾아서 실행
-3. system_call()함수에서 eax로부터 시스템 콜 번호를 찾아, 해당 번호에 맞는 시스템콜 함수로 이동
-4. 해당 시스템콜 함수 실행 후 , 다시 커널 모드에서 사용자 모드로 변경, 다시 해당 프로세스 다음 코드 진행
*%ebx = 자료형? int,unsigned int?

API -동적, 정적 라이브러리 
-응용 프로그램과 분리된 하위 호환 인터페이스
    -예: 시스템 콜 래퍼, 입출력 라이브러리등등
**
바이너리에 추가하는 함수 라이브러리를 붙여 실행파일을 만든다.
= 추가하는 라이브러리가 필요한 경우에만 실행파일에 추가하는 경우 - 분리된 상태
바이너리가 바뀌는 경우에도 필요한 라이브러리를 호출해 사용 = 분리된 상태로 사용
장점: api를 업데이트 시키면 모든 api 사용하는 바이너리 모두 업데이트


예)
process_fork()-프로그래머가 사용하기 쉽게 인터페이스 제공{
    fork() - 시스템 콜
} = 라이브러리 
    

OS->라이브러리<->응용프로그램
예)
응용프로그램 코드 변경이 없고 라이브러리 변경만 조금 한다면 대부분의 프로그램 사용 가능

C라이브러리
-유닉스 C라이브러리 - libc
-리눅스 라이브러리 - GNU libc, glibc(지립씨, 글립씨)
    -시스템콜, 시스템콜 래퍼, 기본 응용프로그램 기본 기능
 
C컴파일러
-유닉스 C 컴파일러 - cc
-리눅스 C 컴파일러 - GNU cc-gcc(지씨씨)
-우분투 리눅스에 gcc설치

예)
gcc-o(옵션) test.c(소스) test(실행파일) : -o 는 소스 뒤에 넣어도 가능

ABI(Application Binary Interface) 
-응용 프로그램 바이너리 인터페이스
-함수 실행 방식, 레지스터 활용, 시스템 콜 실행, 라이브러리 링크 방식등
-ABI가 호환되면 재컴파일없이 동작
-컴파일러, 링커(라이브러리 링크), 툴체인(컴파일러를 만드는 프로그램)에서 제공
*링커는 컴파일러 마무리 동작


stack - heap - bss - data - code
max oxff~                   o->ox00

* 응용 프로그램과 라이브러리간의 연결/통신을 누가 정할것이냐 - ABI
* 윈도우 프로그램을 리눅스나 다른 운영체제에서 실행을 못시키는 이유 - ABI가 다르고 시스템콜이 달라서

POSIX
-유닉스 시스템 프로그래밍 인터페이스 표준
-IEEE(Institute of Eletronic and Electronics Engineers)에서 표준화 시도
-리차드 스톨만(자유 소프트웨어 재단)이 POSIX를 표준안 이름으로 제안

C언어 표준
-다양한 C 언어 변종
-ANSI(American National Standards Institute)에서 ANSI C 표준 성립
*리눅스는 POSIX와 ANSI C 지원 - > 표준화된 기법 사용하며 연습.

시스템 프로그래밍과 버전
-끈임없이 표준 업데이트
-프로그래밍 트렌드와 상관없이 시스템 레벨단 기술은 유지되고, 필요
*상위 레벨 프로그래밍을 할지라도, 하위 시스템 레벨을 알고 있으면, 더 나은 또는 성능이 개선된 소프트웨어 개발 가능



