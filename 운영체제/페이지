# 2020 02 05
# 페이징 시스템


페이징 시스템(paging system)
-페이징 개념
    --크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
    --하드웨어 지원이 필요
        ---예)intel x86시스템(32bit)에서 4KB, 2MB, 1GB 지원
    --리눅스에서는 4KB로 paging
    --페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용
    
*실질적인 예를 기반으로 페이징 시스템
-프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어 있다.
-Page Table에는 가상 주소와 물리 주소간 매핑 정보가 있다.

페이징 시스템 
-page 또는 page frame: 고정된 크기의 block (4KB)
-paging system
    --가상 주소 v =(p,d)
        ---p:가상 메모리 페이지
        ---d:p안에서 참조하는 위치 (변위)
        
페이지 크기가 4KB 예
    --가상 주소의 0비트에서 11비트가 변위 (d)를 나타내고,
    --12비트 이상이 페이지 번호가 될 수 있다.

* 페이지번호 p + 변위 d ->실제 물리메모리의 해당 데이터 위치

* 프로세스가 4GB를 사용하는 이유 -32bit 시스템에서 2의 32승이 4GB

페이지 테이블(page table)
-page table
    --물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
     --가상 주소 v =(p,d)
        ---p:페이지 번호
        ---d:페이지 처음부터 얼마 떨어진 위치인지
-page system 동작
    --해당 프로세스에서 특정 가상 주소 엑세스를 하려면
        ---해당 프로세스의 page table에 해당 가상 주소가 포함된 page 번호가 있는지 확인
        ---page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아내고(p')
        ---p'+d가 실제 물리 주소가 된다.
        
페이징 시스템과 MMU(컴퓨터 구조)
-CPU는 가상 주소 접근시
    --MMU 하드웨어 장치를 통해 물리 메모리 접근

-프로세스 생성시, 페이지 테이블 정보 생성
    --PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
    --프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
    --CPU가 가상 주소 접근시, MMU가 페이지 테이블 base주소를 접근해서, 물리 주소를 가져옴
 
 
 
# 2020 02 05
# 다중 단계 페이징 시스템과 페이징 시스템 장점

다중 단계 페이징 시스템
-32bit 시스템에서 4KB 페이지를 위한 페이징 시스템은
    --하위 12bit는 오프셋
    --상위 20bit가 페이징 번호이므로, 2의 20승(1048576)개의 페이지 정보가 필요함
-페이징 정보를 단계를 나누어 생성
    --필요없는 페이지는 생성하지 않으면, 공간 절약 가능
    
다중 단계 페이징 시스템
-페이지 번호를 나타내는 bit를 구분해서, 단계를 나눔(리눅스는 3단계, 최근 4단계)


MMU와 TLB(컴퓨터 구조)
-MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함
TLB(TRanslation Lookaside Buffer):페이지 정보 캐쉬

페이징 시스템과 공유 메모리
-프로세스간 동일한 물리 주소를 가리킬 수 있음(공간 절약, 메모리 할당 시간 절약)
-물리 주소 데이터 변경시
    --물리 주소에 데이터 수정 시도시, 물리 주소를 복사할 수 있음(copy-on-write)
    
    
# 2020 02 07
# 페이지 폴트

요구 페이징(Demand Paging 또는 Demanded Paging)
-프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
    --선행 페이징(anticipatory paging 또는 prepaging)의 반대 개념: 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
    --더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)
   
페이지 폴트(page fault)
-어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
-운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림

*
페이지 폴트가 자주 일어나면?
    -실행되기 전에, 해당 페이지를 물리 메모리에 올려야 함
        --시간이 오래 걸림
페이지 폴트가 안 일어나게 하려면?
    -향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 됨
        --앞으로 있을 일을 예측해야 함-신의 영역
 
# 2020 02 07
# 페이지 교체 정책

페이지 교체 정책(page replacement policy)
-운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 다 차있다면?
    --기존 페이지중 하나를 물리 메모리에서 저장 매체로 내리고(저장)
    --새로운 페이지를 해당 물리 메모리 공간에 올린다.
    
페이지 교체 알고리즘(FIFO)
-FIFO Page Replacement Algorithm
    --가장 먼저 들어온 페이지를 내리자
페이지 교체 알고리즘(OPT)
-최적 페이지 교체 알고리즘(OPTimal Replacement Algorithm)
    --앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자
    --일반 OS에서는 구현 불가
페이지 교체 알고리즘(LRU) *가장 많이 사용
-LRU(Least Recently Used)Page Replacement Algorithm
    --가장 오래 전에 사용된 페이지를 교체
    --OPT 교체 알고리즘이 구현이 불가하므로, 과거 기록을 기반으로 시도
페이지 스왑 알고리즘(LFU)
-LFU(Least Frequently Used)Page Replacement Algorithm
    --가장 적게 사용된 페이지를 내리자
페이지 스왑 알고리즘(NUR)
-NUR(Not Used Recently) Page Replacement Algorithm
    --LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
    --각 페이지마다 참조 비트(R),수정비트(M)을 둠(R,M)
        ---(0,0),(0,1),(1,0),(1,1) 순으로 페이지 교체
스레싱(Thrashing)
-반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황



